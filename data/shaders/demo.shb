#pragma shader_version 1.0

head 
[
	textureColor 		= "default_texture"; // azfazfaz 
	textureNormalMap 	= "default_normal_map"; 
];

global(gbuffer, g_buffer_resolve)
[
	struct VSInput
	{
		[[vk::location(0)]] float4 Pos 		: POSITION0;
		[[vk::location(1)]] float2 UV 		: TEXCOORD0;
		[[vk::location(2)]] float3 Color 	: COLOR0;
		[[vk::location(3)]] float3 Normal 	: NORMAL0;
		[[vk::location(4)]] float3 Tangent 	: TEXCOORD1;
	};

	struct VSOutput
	{
		[[vk::location(0)]] float4 Pos 		: POSITION0;
		[[vk::location(0)]] float3 Normal 	: NORMAL0;
		[[vk::location(1)]] float2 UV 		: TEXCOORD0;
		[[vk::location(2)]] float3 Color 	: COLOR0;
		[[vk::location(3)]] float3 WorldPos 	: POSITION0;
		[[vk::location(4)]] float3 Tangent 	: TEXCOORD1;
	};

	struct FSOutput
	{
		float4 Position 	: SV_TARGET0;
		float4 Normal 		: SV_TARGET1;
		float4 Albedo 		: SV_TARGET2;
	};
];

vertex(gbuffer)
[
	#include "ubo_definition.cg"

	VSOutput main(VSInput input, uint InstanceIndex : SV_InstanceID)
	{
		VSOutput output = (VSOutput)0;
		float4 tmpPos = input.Pos + ubo.instancePos[InstanceIndex];

		output.Pos = mul(ubo.projection, mul(ubo.view, mul(ubo.model, tmpPos)));

		output.UV = input.UV;

		// Vertex position in world space
		output.WorldPos = mul(ubo.model, tmpPos).xyz;

		// Normal in world space
		output.Normal = normalize(input.Normal);
		output.Tangent = normalize(input.Tangent);

		// Currently just vertex color
		output.Color = input.Color;
		return output;
	}
];

fragment(gbuffer) => "demo_fragment.shb"