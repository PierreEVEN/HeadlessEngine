
vertex(gbuffer)
[
struct VertOut
{
    [builtin(position)] position: vec4<f32>
}

struct FragOut
{
    [location(0)] color: vec4<f32>
}

struct VertIn
{
	[location(0)] position: vec3<f32>
}

[entry(vert)]
fn main(input: VertIn) -> VertOut
{
    let output: VertOut;
    
    let uv = vec2<f32>(0, 0);
    //let uv = vec2<f32>((vertex_index << 1) & 2, vertex_index & 2);
    output.position = vec4<f32>(uv * 2.0f - 1.0f, 0.0f, 1.0f);
}

]



fragment(gbuffer)
[
[layout(std140)]

struct VertOut
{
    [builtin(position)] position: vec4<f32>
}

struct FragOut
{
    [location(0)] color: vec4<f32>
}



[entry(frag)]
fn main(input: VertOut) -> FragOut
{
    let output: FragOut;
    output.color = vec4<f32>(1, 1, 1, 1);
    return output;
}

struct VertIn
{
	[location(0)] position: vec3<f32>
}

]


























/*
#pragma shader_language HLSL

global(gbuffer)
[
struct VsToFsStruct
{
    float4 Pos : POSITION0;
};
]

vertex(gbuffer)
[
struct ViewUbo
{
    float4x4 projection;
    float4x4 view;
    float end;
};

cbuffer view_ubo : register(b0)
{
    ViewUbo view_ubo;
}

struct VsInput
{
    float3 pos : POSITION0;    
};

VsToFsStruct main(VsInput input, uint vertex_index : SV_VertexID)
{
    VsToFsStruct output = (VsToFsStruct) 0;

    float2 uv = float2((vertex_index << 1) & 2, vertex_index & 2);
    output.Pos = float4(uv  * 2.0f - 1.0f, 0.0f, 1.0f);
    return output;
}
];

fragment(gbuffer) 
[
struct FSOutput
{
    float4 Color1 : SV_TARGET0;
    float4 Color2 : SV_TARGET1;
    float4 Color3 : SV_TARGET2;
};
	
FSOutput main(VsToFsStruct input)
{
    FSOutput output = (FSOutput) 0;
    output.Color1 = float4(1, 1, 1, 1);
    output.Color2 = float4(1, 1, 1, 1);
    output.Color3 = float4(1, 1, 1, 1);
    return output;
}
];
*/

/*
#pragma shader_language GLSL

global(gbuffer)
[
#version 450
]

vertex(gbuffer)
[
layout(location = 0) in vec3 inPos;

void main()
{
    vec2 uv = vec2((gl_VertexIndex << 1) & 2, gl_VertexIndex & 2);
    gl_Position = vec4(uv * 2.0f - 1.0f, 0.0f, 1.0f);
}
]

fragment(gbuffer)
[
layout (location = 0) out vec4 outPosition;
layout (location = 1) out vec4 outNormal;
layout (location = 2) out vec4 outAlbedo;

void main()
{
    outPosition = vec4(1, 1, 1, 1.0);
    outNormal = vec4(1, 1, 1, 1.0);
    outAlbedo = vec4(1, 1, 1, 1.0);
}
]
*/