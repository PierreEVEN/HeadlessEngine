#include "shader_builder_test.h"
#include <atlbase.h> // Common COM helpers.
#include <cpputils/logger.hpp>
#include <dxcapi.h>
#include <string>

#include <spirv_reflect.h>

namespace shader_builder
{
void test()
{
    CComPtr<IDxcUtils>          utils;
    CComPtr<IDxcCompiler3>      compiler;
    CComPtr<IDxcIncludeHandler> include_handler;
    DxcCreateInstance(CLSID_DxcUtils, IID_PPV_ARGS(&utils));
    DxcCreateInstance(CLSID_DxcCompiler, IID_PPV_ARGS(&compiler));

    utils->CreateDefaultIncludeHandler(&include_handler);

    LPCWSTR compiler_args[] = {
        L"myshader.hlsl", // Optional shader source file name for error reporting and for PIX shader source view.
        L"-E",
        L"main", // Entry point.
        L"-T",
        L"ps_6_0", // Target.
        L"-Zs",    // Enable debug information (slim format)
        L"-D",
        L"MYDEFINE=1", // A single define.
        L"-Fo",
        L"myshader.bin", // Optional. Stored in the pdb.
        L"-Fd",
        L"myshader.pdb",    // The file name of the pdb. This must either be supplied or the autogenerated file name must be used.
        L"-Qstrip_reflect", // Strip reflection into a separate blob.
        L"-spirv",          // generate a spirv code
    };

    std::string data = "struct VSInput \
    {\
        [[vk::location(0)]] float4 Pos : POSITION0;\n\
        [[vk::location(1)]] float2 UV : TEXCOORD0;\n\
        [[vk::location(2)]] float3 Color : COLOR0;\n\
    };\n\
\n\
    struct VSOutput\n\
    {\n\
    };\n\
\n\
    cbuffer UBO : register(b0)\n\
    {\n\
        float4x4 projection;\n\
        float4x4 view;\n\
        float4x4 model;\n\
    };\n\
\n\
    VSOutput main(VSInput input)\n\
    {\n\
        VSOutput output = (VSOutput)0;\n\
        return output;\n\
    }\n\
    ";

    DxcBuffer source_code;
    source_code.Ptr      = data.c_str();
    source_code.Size     = data.size();
    source_code.Encoding = DXC_CP_ACP; // Assume BOM says UTF8 or UTF16 or this is ANSI text.

    CComPtr<IDxcResult> results;
    compiler->Compile(&source_code,            // Source buffer.
                      compiler_args,           // Array of pointers to arguments.
                      _countof(compiler_args), // Number of arguments.
                      include_handler,         // User-provided interface to handle #include directives (optional).
                      IID_PPV_ARGS(&results)   // Compiler output status, buffer, and errors.
        );

    //
    // Print errors if present.
    //
    CComPtr<IDxcBlobUtf8> pErrors = nullptr;
    results->GetOutput(DXC_OUT_ERRORS, IID_PPV_ARGS(&pErrors), nullptr);
    // Note that d3dcompiler would return null if no errors or warnings are present.
    // IDxcCompiler3::Compile will always return an error buffer, but its length will be zero if there are no warnings or errors.
    if (pErrors != nullptr && pErrors->GetStringLength() != 0)
        wprintf(L"Warnings and Errors:\n%S\n", pErrors->GetStringPointer());

    //
    // Quit if the compilation failed.
    //
    HRESULT hrStatus;
    results->GetStatus(&hrStatus);
    if (FAILED(hrStatus))
    {
        wprintf(L"Compilation Failed\n");
        LOG_FATAL("error 3");
    }
    LOG_VALIDATE("compilled");

    CComPtr<IDxcBlob>      shader      = nullptr;
    CComPtr<IDxcBlobUtf16> shader_name = nullptr;
    results->GetOutput(DXC_OUT_OBJECT, IID_PPV_ARGS(&shader), &shader_name);

    SpvReflectShaderModule module;
    SpvReflectResult       result = spvReflectCreateShaderModule(shader->GetBufferSize(), shader->GetBufferPointer(), &module);
    assert(result == SPV_REFLECT_RESULT_SUCCESS);

    uint32_t var_count = 0;
    result             = spvReflectEnumerateInputVariables(&module, &var_count, NULL);
    assert(result == SPV_REFLECT_RESULT_SUCCESS);
    SpvReflectInterfaceVariable** input_vars = static_cast<SpvReflectInterfaceVariable**>(malloc(var_count * sizeof(SpvReflectInterfaceVariable*)));
    result                                   = spvReflectEnumerateInputVariables(&module, &var_count, input_vars);

    const char* entry_point;
    spvReflectGetEntryPoint(&module, entry_point);

    LOG_WARNING("%s", entry_point);

    for (size_t i = 0; i < var_count; ++i)
    {
        LOG_WARNING("%s", input_vars[i]->name);
    }

    assert(result == SPV_REFLECT_RESULT_SUCCESS);

    spvReflectDestroyShaderModule(&module);
}
} // namespace shader_builder
