#pragma once
#include <memory>
#include <mutex>
#include <unordered_map>

#include "asset_id.h"
#include "asset_ptr.h"
#include "types/nonCopiable.h"

#include <cpputils/logger.hpp>
#include <cpputils/eventmanager.hpp>

DECLARE_DELEGATE_MULTICAST(EventOnDeleteAsset, AssetBase*);

class GfxInterface;
class AssetBase;



class AssetManager
{

  public:
    AssetManager() = default;

    template <typename AssetManager_T, typename... Args> static void initialize(Args&&... arguments)
    {
        set(std::make_shared<AssetManager_T>(std::forward<Args>(arguments)...));
    }

    template <typename AssetManager_T = AssetManager> static AssetManager_T* get()
    {
        return static_cast<AssetManager_T*>(get_internal().get());
    }

    [[nodiscard]] static bool is_valid();

    static void destroy();

    ~AssetManager();

    template <class AssetClass, typename... Args> TAssetPtr<AssetClass> create(const AssetId& asset_id, Args... args)
    {
        if (exists(asset_id))
        {
            LOG_ERROR("Cannot create two asset with the same id : %s", asset_id.to_string().c_str());
            return nullptr;
        }

        AssetClass* asset_ptr = static_cast<AssetClass*>(std::malloc(sizeof(AssetClass)));
        if (!asset_ptr)
            LOG_FATAL("failed to create asset storage");
        asset_ptr->internal_constructor(asset_id);

        new (asset_ptr) AssetClass(std::forward<Args>(args)...);
        asset_map_lock.lock();
        assets[asset_id] = asset_ptr;
        asset_map_lock.unlock();
        return asset_ptr;
    }

    void remove(IAssetPtr* asset_reference);

    bool exists(const AssetId& id)
    {
        return assets.find(id) != assets.end();
    }

    [[nodiscard]] AssetBase*                              find(const AssetId& id);
    [[nodiscard]] AssetId                                 find_valid_asset_id(const std::string& asset_name);
    [[nodiscard]] std::unordered_map<AssetId, AssetBase*> get_assets();

    void try_delete_dirty_items();

    EventOnDeleteAsset on_delete_asset;

  private:
    static void                          set(std::shared_ptr<AssetManager> in_asset_manager);
    static std::shared_ptr<AssetManager> get_internal();

    std::mutex                              asset_map_lock;
    std::mutex                              dirty_assets_lock;
    std::unordered_map<AssetId, AssetBase*> assets;
    std::list<AssetBase*>                   assets_to_delete;
};

class AssetBase : public NonCopiable
{
  public:
    friend class AssetManager;

    virtual std::string to_string() const;

    [[nodiscard]] AssetId get_id() const;

    // Transient resources are not saved and are always generated by code
    virtual bool is_transient_resource();

    virtual bool try_load();

    // Return true when the asset can be safely deleted
    virtual bool try_delete();

    virtual ~AssetBase();

    EventOnDeleteAsset on_delete_asset;

  protected:
    AssetBase() = default;

  private:
    void internal_constructor(const AssetId& id);

    AssetId* asset_id;
};